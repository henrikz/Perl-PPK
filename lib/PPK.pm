package PPK;

use strict;
use Carp;
use Ted::Lambda qw( ncurry );

require Exporter;
our @ISA     = ('Exporter');
our @EXPORT = qw(parse pure zero char re recur
                 seq predicate choice many many1 sepby sepby1 endby1
                 bracket first1 second1 last1 token chartkn
                 expression left right prefix
                 do_applicative);


=head1 NAME

PPK - Perfect Parser Kit

=head1 SYNOPSIS

use PPK;

=head1 DESCRIPTION

Combinatory parser library, that lets you build complicated parsers
by combining basic parsers in a number of ways.

Your parser will work without the extra compilation step that is necessary
when using a parser generator such as Yapp.

So how does it work? The library contains mainly parsers generators. Some of them
generate simple parsers that parse directly from a string, and some are composite
parser generators - known as parser combinators - that combines the action of other
parsers.

=head2 Primitive parsers

The most simple parser there is, is the zero parser, which is generated by the zero()
parser generator.

   zero('a')

A zero parser is a parser that always fails when applied:

   zero('a')->('b')    ->  { type     => 'Parse error',
                             input    => 'b',
                             expected => 'a' }

The opposite is the pure parser, that will always succeed:

  pure('a')->('b')     ->  ['a', 'b']

The return value from a succeeding parser consists of pair of the parsed value
and the rest of the string. The pure parser does not consume anything, so it just
returns the input string as the parsed string.

zero and pure parsers are not much fun by themselves, but they are very important in
combination with other parsers.

There are 2 primitive parsers that actually parses something. The first the char parser:

  char('a')->('abc')    -> ['a', 'bc']

If you call the parser char('a') on a string that doesn't start with an 'a', it will call
zero('a')->(<input>) to produce an error.

The other consumint, primitive parser is the regex parser, which is genereated by the re()
parser generator.

  re('[:alpha:]')

will parse any alphabetic letter:

  re('[:alpha:]')->('abc')  -> ['a','bc']

  re('[:alpha:]')->('123')  -> { 'input' => '123',
                                 'expected' => '[:alpha:]',
                                 'type' => 'Parse error' }

=head2 Basic parser combinators

The parser combinators take other parsers as arguments, and combine them into new parsers.
It is important to note, that parser combinators combine parsers, and not parser generators.

Probably the first thing you would want to do, is to sequence parsers, so you can parse
more the one character or regex. This is where the seq() parser comes in:

  seq(sub { [shift(), shift()] }, char('a'), char('b'))->('ab')   -> [['a','b'], '']

The seq() parser builds on other - let's call them underlying - parsers that will be
invoked in sequence. What then should seq() return as it's parser value? You need to decide
that yourself. The first argument to seq is a function that will receive the parser values
of it's underlying parsers. The return value of this function will be the return value
of the seq() parser.

The next thing you would want, is choice. Say, you want to be able to parse a value that is
either a word or a number. The choice() parser will let you do that.

  choice(re('[:digit:]'), re('[:alpha:]')->('123ABC')   ->  [ 123,  'ABC']
  choice(re('[:digit:]'), re('[:alpha:]')->('ABC123')   ->  ['ABC', '123']

A choice parser will return the parser value from the parser that succeeded. 

You can now combine seq() and choice() parsers as you wish.
Example:

  # Parse a name, either "<firstname> <lastname>" or "<lastname>, <lastname>" and
  # return it in a hash.
  my $name   = re('[[:alpha:]]+', 'name');
  my $space1 = re('[[:space:]]+');
  my $space  = choice($space1, pure(''));
  my $comma  = seq(sub { return '' }, $space, char(','), $space);

  my $fullname = choice(seq(sub { ($fn, $sp, $ln) = @_;
                                  return { firstname => $fn, lastname => $ln };
                              }, $name, $space, $name),
                        seq(sub { ($ln, $cm, $fn) = @_;
                                  return { firstname => $fn, lastname => $ln };
                              }, $name, $comma, $name));
  
  
  $fullname->("Donald Duck")       -> [{ firstname => 'Donald', lastname => 'Duck' }, '']
  $fullname->("Duck, Donald")      -> [{ firstname => 'Donald', lastname => 'Duck' }, '']

So here you have choice() inside a seq() inside a choice(). The construct $space means optional space.
It can parse either space or nothing - remember that pure() always succeeds, and never consumes anything.
So, in general, this is how you make a parser optional. In this special case there is another option though.
Since we are dealing with a re() parser, you could instead adjust the regular expression to '[[:space:]]+'.
That's a bit more efficient, but only works for re() parsers.

Now, the above $fullname parser works, and it is very intuitively written, which is good. However, it is
not very efficient. Let's take a closer look:

In the first option in the outer choice we have a seq() consisting of the parsers
  1) $name, $space, $name

while the second options consists of
  $name, $comma, $name

If we expand $comma, we get the parser sequence
  2) $name, $space, char(','), $space, $name

The thing to note here, is that the first 2 parsers ($name and $space), are the same for 1) and for 2).
This means, that if we have a string that matches 2), like "Mouse , Mickey", then the parser will parse
"Mouse" ($name), and " " ($space), before finding out that this is wrong, because $name can't parse the
next thing (", Mickey").

Then, it will go back to scratch, parse the same to items ("Mickey" and " ") once again. So, let's rewrite
it:

  $fullname = seq(sub { my ($name1, $sp, $name2) = @_;
                        return (ref $name2 eq 'ARRAY')? { lastname => $name1, @$name2 } :
                            { firstname => $name1, lastname => $name2 };
                    }, $name, $space, choice($name,
                                             seq(sub { my ($sp1, $sp2, $name) = @_;
                                                       return [ firstname => $name ] }, char(','), $space, $name)));

This will be more efficient, though it might be slightly less readable. It will of course help if you
give the 2 anonymous functions a name, and just refer to them in the definition of $fullname. This is
left as an exercise to the reader.

It is also left as an exercise for you to expand it to name that includes 'von' or a 'Jr.' or has more than
one first name, like "William Henry Gates III". Forgive me for using this very inappropiate name as an example.

=head1 FUNCTIONS

=over 4

=cut


=item parse($parser, $string[, $error])

Helper function for calling parsers with the right input type.

=cut
sub parse {
    my $parser = shift or croak 'No parser';
    my $string = shift // croak 'No string';
    my $error  = shift;

    my $result = $parser->($string);
    ## Succesful parse
    if (ref $result eq 'ARRAY') {
        return (shift @$result);
    }
    ## Error using error function
    elsif ($error) {
        return $error->($result);
    }
    ## Croak error
    else {
        my $expect = $result->{expected};
        if (ref $expect eq 'ARRAY') {
            $expect = "one of [" . join(']|[', @$expect) . "]";
        }
        croak "$result->{type}: Expected $expect in input [$result->{input}]";
    }
}


=item fmap($f, $p)

Maps parser value obtained from the parser $p by applying $f.

=cut
sub fmap {
    my $f = shift or croak 'No f';
    my $p = shift or croak 'No p';
    return combine(pure($f), $p);
}

=item pure($v)

Pure parser will always succeed without consuming anything.
$v will be the parser value returned from the parser.

### $v -> ($s -> [$v, $s])

=cut
sub pure {
    my $v = shift; croak if !defined $v;
    return sub {
        my $inp = shift;
        return [$v, $inp];
    }
}

# applicative parser combination
# (<*>) :: Parser (a -> a') -> Parser a -> Parser a'
# ff <*> fv = \inp -> do (f', inp')  <- ff inp
#                        (v', inp'') <- fv inp'
#                        return (f' v', inp'')
sub combine {
    my $ff = shift or croak 'No ff';
    my $fv = shift or croak 'No fv';
    
    sub {
        my $inp = shift;

        my $fs = $ff->($inp);
        if (ref $fs eq 'ARRAY') {
            my ($fm, $inpm) = @$fs;

            my $vs = $fv->($inpm);
            # Possible lazyness
            if ( ref $vs eq 'CODE') {
                $vs = $vs->($inpm);
            }
            if (ref $vs eq 'ARRAY') {
                my ($vm, $inpmm) = @$vs;
                return [$fm->($vm), $inpmm];
            }
            else {
                return $vs;
            }
        } else {
            return $fs;
        }
    };
}

## (>>-) :: Parser a -> (a -> Parser b) -> Parser b
## (>>=) :: (a -> (a,s)) -> (a -> (b -> (b,s))) -> (b -> (b,s))
## mv: a -> (a,s)
## mf: (a -> (b -> (b,s)))
sub bindp {
    my $mv = shift or croak 'No mv';
    my $mf = shift or croak 'No mf';

    sub {
        my $inp = shift;
        my $res = $mv->($inp);
        ## Lazy?
        if ( ref $res eq 'CODE' ) {
            $res = $res->($inp);
        }
        if ( ref $res eq 'ARRAY' ) {
            my ($v, $inpm) = @$res;
            return $mf->($v)->($inpm);
        }
        else {
            return $res;
        }
    };
}


### TODO: End of file, and not end of file
sub string2errmsg {
    my $inp    = shift;
    my $maxlen = shift || 25;
    
    if ( length($inp) == 0) {
        $inp = "<end-of-string>";
    }
    elsif ( length($inp) >= $maxlen) {
        $inp = substr($inp, 0, $maxlen) . " ...";
    }
    return $inp;
}


=item zero($expected)

Parser that allways fails.

$expected will be parsed on to the error
value returned by the application of the parser.

=cut
sub zero {
    my $expected   = shift;
    
    sub {
        my $inp      = shift;

        return { type       => 'Parse error',
                 input      => $inp,
                 expected   => $expected,
             };
    }
};

=item char($c)

Parses character $c. Fails if the first character found it not equal to $c.

=cut
sub char {
    my $c = shift; croak 'No c' if ! defined $c;
    
    sub {
        my $inp = shift;
        my ($s1, $s2) = (substr($inp, 0, 1), substr($inp, 1));
        if ($s1 eq $c) {
            return pure($s1)->($s2);
        }
        else {
            return zero($c)->($inp);
        }
    }
}

=item re([$f, ]$regex[, $description)

Regex parser. Will parse if the beginning of the string matches $regex.

You can optionally supply:
  $f     map function to be applied to the parsed value
  $desc  description to be used for error reporting, eg. 'number' or 'float' or 'string'

Note the meaning of the special regex characters [^$.]:

   ^,$   - matches beginning and end of line respectively.
   .     - matches every character, including newline.

Space - including newline - will be discarded from the regex, allowing
you to format your regex nicely. If you need to match a space, you will
need to use \s or [:space:].

=cut
sub re {
    my $f;
    my $s           = shift or croak 'No s';
    if ( ref $s eq 'CODE') {
        $f = $s;
        $s = shift or croak 'No s';
    }
    my $description = shift || $s;
    my $regex = qr{\A($s)(.*)\z}xms;
    
    sub {
        my $inp = shift;
        my ($s1,$s2) = $inp =~ $regex;
        if (defined $1) {
            $s1 = $f->($s1) if defined $f;
            return pure($s1)->($s2);
        }
        else {
            return zero($description)->($inp);
        }
    };
}

=item recur(\&pg, $arg1 ...)

Make a lazy parser generator for use in recursive parsers.

Example
   strict: many($p)
   lazy  : recur(\&many, $p)

This is necessary when constructing recursive parsers
NB:: There is 2 kinds of recursion:
           - recursion using parser
           - recursion using a parser generator.
recur() works with parser generators, and not with parsers.

=cut
sub recur {
    my $f    = shift or croak 'No f';
    my $args = \@_;
    my $p    = undef;
    
    return sub {
        # Optimization, keep the generated parser for next time.
        $p = $f->(@$args) if ! defined $p;
        return $p->(@_);
    };
}



=item seq($f, $p1, $p2 ...)

The resulting parser will try to apply the parsers $p1, $p2 ... in sequence. If
one of the parsers fails, seq will fails with that parsers error record.
Combines the parsed values into a list.


Sample:
  seq($f, char('a'), char('b'))

This parser will parse 'ab', yielding $f->('a','b') as it's parsed value.

=cut
sub seq {
    my $f   = shift or croak 'No f';
    return do_applicative(\&pure, \&combine, $f, @_);
}


=item predicate($pred, p)

If parser $p succeeds, then test the result with $pred and subsequently
succeed only if $pred->(<result of $p>) returns a true value.

=cut
sub predicate {
    my $pred = shift or croak 'No pred';
    my $p    = shift or croak 'No p';

    return bindp($p, sub {
                     my $v = shift;
                     if ($pred->($v)) {
                         return pure($v);
                     }
                     else {
                         return zero("Parsed value [$v] failed predicate");
                     }
                 });
}

=item choice($p1, $p2 ...)

Try a set of parsers. Return the result of the first succesful one.

=cut
sub choice {
    my @parsers = @_;
    sub {
        my $inp = shift;
        my @results = map {
            my $st = $_->($inp);
            ## Possible lazyness
            if (ref $st eq 'CODE') {
                $st = $st->($inp);
            }
            if (ref $st eq 'ARRAY') {
                return $st;
            }
            $st;
        } @parsers;
        ## Select the errors where the parse advanced the most,
        ## ie. input left is as small as possible
        my ($errors) = mostn(sub { return -(length(shift()->{input})); },
                             \@results);
        my @expected = map { $_->{expected} } @$errors;
        return zero(flatten(\@expected))->($errors->[0]->{input});
    }
}


## Ideas for support functions: list, last, number, etc.
sub listseq {
    return seq(\&list, @_);
}

sub cons2 {
    my ($p1, $p2) = @_;
    return seq(\&cons, $p1, $p2);
}

=item many($p)

Apply $p none or many times. Resulting value is a list of the parsed values, eg.

 many(char('a')) applied to 'aaa' will give you ['a', 'a', 'a'].
 many(char('a')) applied to 'baa' will give you [].

=cut
sub many {
    my $p  = shift or croak 'No p';
    
    return sub {
        my $inp = shift;
        my ($item, $token);
        my @ret = ();
        
        while (ref($token = $p->($inp)) eq 'ARRAY') {
            ($item, $inp) = @$token;
            push @ret, $item;
        }
        return [\@ret, $inp];
    };
}

=item many1($p)

Like many, but requires at least one succesfull application of $p, otherwise it will fail.

=cut
sub many1 {
    my $p = shift or croak 'No p';

    return cons2($p, many($p));
}


### Sequence delimited by $s. Delimiters are ignored in the parsing result
sub sepby1 {
    my $p = shift or croak 'No p';
    my $s = shift or croak 'No s';

    return cons2($p, many(last1($s, $p)));
}

sub endby1 {
    my $p = shift or croak 'No p';
    my $s = shift or croak 'No s';

    return many1(first1($p, $s));
}

### Left associative operators
sub chainl1 {
    my $p = shift or croak 'No p';
    my $s = shift or croak 'No s';

    return seq(\&map2ltree, $p, many(listseq($s, $p)));
}

## Right associative operators
sub chainr1 {
    my $p  = shift or croak 'No p';
    my $s  = shift or croak 'No s';

    return seq(\&consrtree,
               $p,
               choice(listseq($s, recur(\&chainr1, $p, $s)),
                      pure([])));
}

### TODO: POD
sub bracket {
    my $open  = shift or croak 'No open';
    my $p     = shift or croak 'No p';
    my $close = shift // $p;

    return seq(\&rtsecond, $open, $p, $close);
}

sub first1 {
    return seq(\&rtfirst, @_);
}

sub second1 {
    return seq(\&rtsecond, @_);
}

sub last1 {
    return seq(\&rtlast, @_);
}


sub token {
    return last1(re('\s*'), re(@_));
}


sub chartkn {
    return last1(re('\s*'), char(@_));
}


=item expression($p, $operator ...)

Builds parsers for expressions based on unary or binary operators, like
arithmetic or logic expression. The parser returns a parse tree.

You need to provide
   $p         Parser for the basic expression
   $operator  Parser generators in precedence order

The parser generators that can be used with expression(), are: left, right, and prefix.

Example: a simple parser for arithmetic expressions

 $parser =
    expression(re('\d+', 'number'),
               prefix(choice(char('+'), char('-'))),
               left  (char('^')),
               left  (choice(char('*'), char('/'))),
               left  (choice(char('+'), char('-'))),
               right (char('&')),
               right (char('|')));


=cut
sub expression {
    my $p = shift or croak 'No p';
    my @table = @_;
    my $exp = $p;

    foreach my $builder(@table) {
        $exp = $builder->($exp);
    }
    return $exp;
}

=item left($op)

Creates a left associative infix operator for use in the expression() parser generator.
See expression() for sample usage.

=cut
sub left {
    my $op = shift or croak 'No op';
    return sub {
        my $p = shift or croak 'No p';
        return chainl1($p, $op);
    };
}


=item right($op)

Creates a right associative infix operator for use in the expression() parser generator.
See expression() for sample usage.

=cut
sub right {
    my $op = shift or croak 'No op';
    return sub {
        my $p = shift or croak 'No p';
        return chainr1($p, $op);
    };
}


=item prefix($op)

Creates a prefix operator for use in the expression() parser generator.
See expression() for sample usage.

=cut
sub prefix {
    my $op = shift or croak 'No op';
    my $prefix;
    $prefix = sub {
        my $p = shift or croak 'No p';
        return choice($p, listseq($op, recur($prefix, $p)));
    };
    return $prefix;
}


### HELPERS ####
### Attach an element to the front of a list
sub cons {
    my $e   = shift or croak 'No e';
    my $arr = shift or croak 'No arr';

    return [$e, @$arr];
}

### Returns the arguments as a list ref
sub list {
    return \@_;
}

### Returns the last argument
sub rtlast {
    return pop();
}

### Returns the first argument
sub rtfirst {
    return shift();
}

sub rtsecond {
    shift();
    return shift();
}

sub consrtree {
    my ($x, $recur) = @_;
    return $x if ! @$recur;
    my ($op, $xtree) = @$recur;
    return [ $op, $x, $xtree ]
}

sub map2ltree {
    my $left  = shift or croak 'No left';
    my $pairs = shift or croak 'No pairs';
    
    my $pair;
    while (defined ($pair = shift @$pairs)) {
        my ($op, $right) = @$pair;
        $left = [$op, $left, $right];
    }
    return $left;
}

###
sub flatten {
    my $tree = shift;
    if ( ref $tree ne 'ARRAY') {
        return $tree;
    }
    else {
        my @list = map {
            ref $_ eq 'ARRAY' ? @{flatten($_)} : $_;
        } @$tree;
        return \@list;
    }
}

## The member(s) if a list that scores the highest according to
## some provided score function.
sub mostn {
    my $fn  = shift or croak 'No fn';   # a -> Number
    my $lst = shift or croak 'No lst';  # [a]
    # returns ([a], Number)
    if (@$lst == 0) {
        return ([], undef);
    }
    my $max    = $fn->($lst->[0]);
    my $score;
    my $len = @$lst;
    my @mosts = $lst->[0];
    foreach my $e (@$lst[1..($len-1)]) {
        $score = $fn->($e);
        if ( $score == $max ) {
            push @mosts, $e;
        }
        elsif ( $score > $max ) {
            @mosts = ($e);
            $max = $score;
        }
    }
    return (\@mosts, $max);
}

=item do_applicative($star, $pure, $f, @values)

Does an application of a series of applicative functors

  $pure    :: a -> F a
  $combine :: F (a -> b) -> F a -> F b
  $f       :: (a,b ...) -> z
  $values  :: (a,b ...)

f is then transformed into
  $cf      :: F (a -> b -> ... -> z)

Example: The list [] functor

We need to supply the appropiate pure and combine functions.

list_pure is a function that takes a value, and puts in into the functor, ie. the list:
  sub list_pure {
      my ($a) = @_;
      return [ $a ];
  }

list_combine take a list of functions, and a list of values and combines the two:
  sub list_combine {
      my ($ff, $fv) = @_;
      my @ret = ();
      my ($f, $v);
      for $f(@$ff) {
          for $v(@$fv) {
              push @ret, $f->($v);
          }
      }
      return \@ret;
  }

Note, if $ff contains only one function, list_compine works like a simple map.

Now, you can do eg.

  do_applicative(\&list_pure,
                 \&list_combine,
                 sub { ($a,$b) = @_; "$a,$b" },
                 [1..2],
                 ['a'..'b']);

     -> ['1,a', '1,b','2,a', '2,b']

=cut
sub do_applicative {
    my $pure     = shift or croak 'No pure';
    my $combine  = shift or croak 'No combine';
    my $f        = shift or croak 'No f';

    my $cf = $pure->(ncurry($f, scalar @_)); # TODO: curry   -> partial
                                             #       ncurry  -> curry
    my $v;
    while (defined ($v = shift @_)) {
        $cf = $combine->($cf,$v);
    }
    return $cf;
}

1;
